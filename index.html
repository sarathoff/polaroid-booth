<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Create nostalgic polaroid photos with filters, decorations, and captions in your browser.">
    <title>Polaroid Booth</title>

    <!-- Google Fonts (Updated to include new fonts) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=DM+Sans:wght@400;500;700&family=Caveat:wght@600;700&family=Patrick+Hand&family=Special+Elite&family=Rock+Salt&display=swap" rel="stylesheet">

    <style>
        :root {
            --font-sans: 'DM Sans', sans-serif;
            --font-display: 'Playfair Display', serif;
            --font-caveat: 'Caveat', cursive;
            --font-patrick-hand: 'Patrick Hand', cursive;
            --font-special-elite: 'Special Elite', cursive;
            --font-rock-salt: 'Rock Salt', cursive;
            --color-bg: #F4F1EC;
            --color-text: #413B35;
            --color-text-muted: #7A7269;
            --color-card-bg: #FDFCFB;
            --polaroid-bg: #FDFCFB; /* For JS access */
            --color-border: #DED8CF;
            --color-input-bg: #FFFFFF;
            --color-primary: #856f5c;
            --color-primary-dark: #6a5949;
            --color-primary-text: #FFFFFF;
            --color-secondary: #EBE6DE;
            --color-secondary-text: #59514A;
            --shadow-color: 23deg 15% 55%;
            --shadow-light: 0.3px 0.5px 0.7px hsl(var(--shadow-color) / 0.22), 0.4px 0.8px 1px -0.8px hsl(var(--shadow-color) / 0.22), 1px 2px 2.5px -1.7px hsl(var(--shadow-color) / 0.22);
            --shadow-medium: 0.3px 0.5px 0.7px hsl(var(--shadow-color) / 0.2), 0.8px 1.6px 2px -0.6px hsl(var(--shadow-color) / 0.2), 2.1px 4.1px 5.2px -1.1px hsl(var(--shadow-color) / 0.2), 5px 10px 12.6px -1.7px hsl(var(--shadow-color) / 0.2);
            --shadow-polaroid: 0 10px 20px rgba(60, 60, 80, 0.1), 0 3px 6px rgba(0, 0, 0, 0.08);
            --radius-small: 6px;
            --radius-medium: 12px;
            --radius-large: 16px;
        }

        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: var(--font-sans);
            background-color: var(--color-bg);
            color: var(--color-text);
            background-image: url('data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="4" height="4" viewBox="0 0 4 4"%3E%3Cpath fill="%239C92AC" fill-opacity="0.06" d="M1 3h1v1H1V3zm2-2h1v1H3V1z"%3E%3C/path%3E%3C/svg%3E');
            line-height: 1.6;
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
        }

        .l-container { max-width: 1200px; margin: 0 auto; padding: 1.5rem; }
        .header { text-align: center; margin-bottom: 2rem; }
        .header__logo { font-family: var(--font-display); font-size: 2rem; font-weight: 700; color: var(--color-primary); text-decoration: none; }

        main {
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 2.5rem;
            align-items: flex-start;
        }

        .controls-panel { position: sticky; top: 1.5rem; }
        .preview-area { position: relative; min-height: 80vh; display: flex; align-items: center; justify-content: center; }

        .c-btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem;
            padding: 0.65rem 1rem; font-family: var(--font-sans); font-weight: 500;
            font-size: 0.9rem; border-radius: var(--radius-small); border: 1px solid transparent;
            cursor: pointer; transition: all 0.2s ease-out; white-space: nowrap;
        }
        .c-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; box-shadow: none !important; }
        .c-btn--primary { background-color: var(--color-primary); color: var(--color-primary-text); border-color: var(--color-primary); box-shadow: var(--shadow-light); }
        .c-btn--primary:not(:disabled):hover, .c-btn--primary:not(:disabled):focus { background-color: var(--color-primary-dark); transform: translateY(-2px); box-shadow: var(--shadow-medium); }
        .c-btn--secondary { background-color: var(--color-secondary); color: var(--color-secondary-text); border-color: var(--color-border); }
        .c-btn--secondary:not(:disabled):hover, .c-btn--secondary:not(:disabled):focus { background-color: #e0d9cf; border-color: #cec5b9; }
        .c-btn svg { width: 16px; height: 16px; }

        .c-card {
            background-color: var(--color-card-bg); border: 1px solid var(--color-border);
            border-radius: var(--radius-large); padding: 1.5rem; box-shadow: var(--shadow-light);
            display: flex; flex-direction: column; gap: 1.25rem;
        }
        .c-card__section { display: flex; flex-direction: column; gap: 1rem; }
        .c-card__section-title { font-size: 0.8rem; font-weight: 700; color: var(--color-text-muted); margin-bottom: -0.25rem; text-transform: uppercase; letter-spacing: 0.5px; }
        
        .c-video-container { position: relative; aspect-ratio: 16 / 9; border-radius: var(--radius-medium); overflow: hidden; background-color: var(--color-secondary); }
        #videoElement { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #cameraOverlay { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.4); color: white; font-size: 0.9rem; text-align: center; padding: 1rem; gap: 1rem; }

        .c-option-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(60px, 1fr)); gap: 0.75rem; }
        .grid-option {
            display: flex; flex-direction: column; align-items: center; gap: 0.5rem; padding: 0.5rem;
            border: 2px solid transparent; border-radius: var(--radius-medium); background-color: var(--color-input-bg);
            cursor: pointer; transition: all 0.2s; border: 1px solid var(--color-border); text-align: center;
        }
        .grid-option:hover { border-color: var(--color-primary); transform: translateY(-2px); }
        .grid-option.active { border-color: var(--color-primary); box-shadow: 0 0 0 2px var(--color-primary); }
        .option-name { font-size: 0.7rem; font-weight: 500; color: var(--color-text-muted); }

        .layout-icon {
            width: 32px;
            height: 32px;
            object-fit: contain;
        }

        .filter-preview { width: 100%; height: 40px; border-radius: var(--radius-small); background-size: cover; background-position: center; }
        .font-preview { font-size: 1.5rem; line-height: 1; }
        .font-Caveat { font-family: var(--font-caveat); }
        .font-Patrick-Hand { font-family: var(--font-patrick-hand); }
        .font-Special-Elite { font-family: var(--font-special-elite); }
        .font-Rock-Salt { font-family: var(--font-rock-salt); }
        .decoration-preview { width: 40px; height: 40px; background-size: contain; background-repeat: no-repeat; background-position: center; }

        .c-input-group { display: flex; flex-direction: column; gap: 0.25rem; }
        .c-label { font-size: 0.8rem; font-weight: 500; color: var(--color-text-muted); }
        .c-input {
            width: 100%; padding: 0.6rem 0.75rem; border-radius: var(--radius-small); border: 1px solid var(--color-border);
            background-color: var(--color-input-bg); font-family: var(--font-sans); font-size: 0.9rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .c-input:focus { outline: none; border-color: var(--color-primary); box-shadow: 0 0 0 2px color-mix(in srgb, var(--color-primary) 30%, transparent); }

        #emptyState { text-align: center; color: var(--color-text-muted); }
        #emptyState svg { width: 4rem; height: 4rem; margin: 0 auto 1rem; opacity: 0.4; }
        #emptyState h3 { font-family: var(--font-display); font-size: 1.5rem; margin-bottom: 0.5rem; color: var(--color-text); }
        
        /* Preview Area Styles */
        .polaroid-output-area, .polaroid-grid-wrapper { perspective: 1500px; }
        .polaroid {
            background: var(--polaroid-bg); border-radius: 4px; box-shadow: var(--shadow-polaroid);
            transition: transform 0.4s ease, box-shadow 0.4s ease; position: relative;
        }
        .polaroid-image-wrapper { background-color: #e0e5f1; aspect-ratio: 1/1; overflow: hidden; }
        .polaroid-image { display: block; width: 100%; height: 100%; object-fit: cover; }
        .polaroid-text { text-align: center; padding: 0.5rem; color: #444; overflow-wrap: break-word; }
        
        .polaroid-output-area { width: 350px; }
        #polaroid-single { padding: 1rem 1rem 4rem; transform: rotate(-2deg); }
        #polaroid-single .polaroid-image-wrapper { margin-bottom: 1.25rem; }
        #polaroid-single .polaroid-text { font-size: 1.5rem; }

        .polaroid-grid-wrapper { display: grid; max-width: 550px; gap: 1.5rem; }
        .polaroid-grid-wrapper.grid-2x2 { grid-template-columns: 1fr 1fr; }
        .polaroid-grid-wrapper.grid-strip, .polaroid-grid-wrapper.grid-4x1 { grid-template-columns: 1fr; max-width: 250px; }
        .polaroid-grid-wrapper .polaroid { width: 100%; padding: 0.75rem 0.75rem 2.5rem; }
        .polaroid-grid-wrapper .polaroid:nth-child(odd) { transform: rotate(-2.5deg); }
        .polaroid-grid-wrapper .polaroid:nth-child(even) { transform: rotate(2.5deg); }
        .polaroid-grid-wrapper .polaroid-image-wrapper { margin-bottom: 0.75rem; }
        .polaroid-grid-wrapper .polaroid-text { font-size: 1.2rem; }

        .decoration { position: absolute; background-size: contain; background-repeat: no-repeat; pointer-events: none; z-index: 10; }
        .deco-ribbon-decoration { top: 0; left: 0; }
        .deco-heart-decoration { top: 0; right: 0; }

        .filter-vintage { filter: sepia(0.35) contrast(1.1) brightness(1.05) saturate(1.2); }
        .filter-mono { filter: grayscale(1); }
        .filter-retro { filter: sepia(0.6) contrast(0.9) brightness(1.1); }
        .filter-gloomy { filter: contrast(1.2) brightness(0.9) saturate(0.8); }
        .filter-mellow { filter: brightness(1.1) contrast(0.95) saturate(0.9); }
        .filter-dreamy { filter: saturate(1.4) contrast(0.9) brightness(1.1) blur(0.5px); }
        .filter-lomo { filter: saturate(1.5) contrast(1.2); }

        .hidden { display: none !important; }
        canvas#canvas { display: none; }

        /* Overlays & Effects */
        .flash-effect { position: fixed; inset: 0; background: white; opacity: 0; pointer-events: none; z-index: 9999; }
        .flash-effect.active { animation: flash 0.3s ease-out; }
        @keyframes flash { 0% { opacity: 0; } 50% { opacity: 0.9; } 100% { opacity: 0; } }

        #countdownOverlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center;
            z-index: 10000; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; backdrop-filter: blur(4px);
        }
        #countdownOverlay.is-active { opacity: 1; pointer-events: all; }
        #countdownNumber {
            font-family: var(--font-display); font-size: 10rem; font-weight: 700; color: white;
            text-shadow: 0 4px 20px rgba(0,0,0,0.5); transform-origin: center;
        }

        /* Download Button Spinner */
        .spinner {
            width: 18px; height: 18px; border: 2px solid rgba(255,255,255,0.3);
            border-top-color: var(--color-primary-text); border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        @media (max-width: 992px) {
            main { grid-template-columns: 1fr; }
            .controls-panel { position: static; max-width: 500px; margin: 0 auto; }
            .preview-area { min-height: auto; padding-top: 2rem; }
        }
        @media (max-width: 480px) {
            .polaroid-output-area, .polaroid-grid-wrapper { width: 100%; max-width: 100%; }
            .polaroid-grid-wrapper.grid-2x2 { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <!-- Overlays -->
    <div id="flashEffect" class="flash-effect"></div>
    <div id="countdownOverlay" aria-live="polite">
        <div id="countdownNumber"></div>
    </div>

    <div class="l-container">
        <header class="header">
            <a href="landing.html" class="header__logo" aria-label="The Timeless Photo Booth Home">Polaroid Booth</a>
        </header>

        <main>
            <!-- CONTROLS PANEL -->
            <aside class="controls-panel">
                <div class="c-card">
                    <!-- 2. LAYOUT & TIMER -->
                    <div class="c-card__section">
                        <div class="c-card__section-title">Layout & Timer</div>
                        <div id="layoutOptions" class="c-option-grid" role="radiogroup">
                             <div class="grid-option layout-option" data-layout="single">
                                <img src="assets/layout-single.svg" alt="Single Photo Layout" class="layout-icon">
                                <span class="option-name">Single</span>
                            </div>
                            <div class="grid-option layout-option" data-layout="grid-2x2">
                                <img src="assets/layout-grid.svg" alt="2x2 Grid Layout" class="layout-icon">
                                <span class="option-name">2x2 Grid</span>
                            </div>
                            <div class="grid-option layout-option" data-layout="grid-strip">
                                <img src="assets/layout-strip.svg" alt="Photo Strip Layout" class="layout-icon">
                                <span class="option-name">Strip</span>
                            </div>
                        </div>
                         <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                            <div class="c-input-group">
                                <label class="c-label" for="timerDelay">Delay (s)</label>
                                <input type="number" id="timerDelay" min="1" max="10" value="3" class="c-input">
                            </div>
                            <div class="c-input-group">
                                <label class="c-label" for="photoCount">Photos</label>
                                <input type="number" id="photoCount" min="1" max="4" value="4" class="c-input">
                            </div>
                        </div>
                        <button class="c-btn c-btn--secondary" id="startTimerBtn" disabled>Start Timer</button>
                        <div id="timerStatus" style="font-size: 0.8rem; text-align: center; color: var(--color-text-muted);"></div>
                    </div>

                    <!-- 1. CAMERA & CAPTURE -->
                    <div class="c-card__section">
                        <div class="c-video-container">
                            <video id="videoElement" autoplay muted playsinline aria-label="Live camera feed"></video>
                            <div id="cameraOverlay" role="alert">Click "Start Camera" to begin</div>
                        </div>
                        <button class="c-btn c-btn--primary" id="startCameraBtn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></svg>
                            Start Camera
                        </button>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                            <button class="c-btn c-btn--secondary" id="captureBtn" disabled>Capture</button>
                            <button class="c-btn c-btn--secondary" id="uploadBtn">Upload</button>
                        </div>
                        <input type="file" id="fileInput" accept="image/*" class="hidden">
                        <button class="c-btn c-btn--secondary" id="switchCameraBtn" disabled>Switch Camera</button>
                    </div>

                    
                    
                    <!-- 3. CUSTOMIZATION -->
                    <div class="c-card__section">
                        <div class="c-card__section-title">Image Filter</div>
                        <div class="c-option-grid" id="filterOptions" role="radiogroup"></div>
                    </div>
                    <div class="c-card__section">
                        <div class="c-card__section-title">Font Style</div>
                        <div class="c-option-grid" id="fontOptions" role="radiogroup"></div>
                    </div>
                     <div class="c-card__section">
                        <div class="c-card__section-title">Decorations</div>
                        <div class="c-option-grid" id="decorationOptions"></div>
                    </div>

                    <!-- 4. FINAL TOUCHES -->
                    <div class="c-card__section" style="padding-top: 1rem; border-top: 1px solid var(--color-border);">
                        <div class="c-card__section-title">Add A Caption</div>
                        <input type="text" id="polaroidText" placeholder="Write a memory..." maxlength="60" class="c-input">
                        <button class="c-btn c-btn--primary" id="downloadBtn" disabled>
                            <span class="btn-text">Download Image</span>
                            <div class="spinner hidden"></div>
                        </button>
                    </div>
                </div>
            </aside>

            <!-- PREVIEW AREA -->
            <section class="preview-area" aria-live="polite">
                <div id="polaroidContainer">
                    <div id="emptyState">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                            <rect width="18" height="18" x="3" y="3" rx="2" ry="2"/>
                            <circle cx="9" cy="9" r="2"/>
                            <path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/>
                        </svg>
                        <h3>Your Photos Appear Here</h3>
                        <p>Start your camera or upload an image to begin.</p>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <canvas id="canvas" aria-hidden="true"></canvas>

    <script>
    document.addEventListener('DOMContentLoaded', () => {

       
        class CanvasDrawer {
            constructor(config) {
                this.config = config;
                this.canvas = document.createElement('canvas'); // Use an in-memory canvas
                this.ctx = this.canvas.getContext('2d');
                this.CONSTANTS = {
                    FONT_SIZE: 90,
                    PADDING: 60,
                    TEXT_AREA_HEIGHT: 220,
                    IMG_SIZE: 1000,
                    POLAROID_WIDTH: 1000 + 60 * 2,
                    get POLAROID_HEIGHT() { return this.IMG_SIZE + this.PADDING + this.TEXT_AREA_HEIGHT; },
                    GRID_GAP: 100
                };
            }

            async _loadAssets(imageSources, activeDecorations) {
                const imagePromises = imageSources.map(src => {
                    const img = new Image();
                    img.src = src;
                    return img.decode().then(() => img).catch(e => console.error("Image load error:", e));
                });

                const decoPromises = [...activeDecorations].map(id => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous'; 
                    img.src = this.config.decorations[id].url;
                    return img.decode().then(() => ({ id, img })).catch(e => console.error("Decoration load error:", e));
                });

                const [loadedImages, loadedDecos] = await Promise.all([
                    Promise.all(imagePromises.filter(p => p)),
                    Promise.all(decoPromises.filter(p => p))
                ]);

                const decoMap = new Map(loadedDecos.map(d => [d.id, d.img]));
                return { loadedImages, decoMap };
            }

            _drawImageWithAspectRatio(img, dx, dy, dWidth, dHeight) {
                const hRatio = dWidth / img.width;
                const vRatio = dHeight / img.height;
                const ratio = Math.max(hRatio, vRatio); // Use max for 'cover' effect
                const centerShiftX = (dWidth - img.width * ratio) / 2;
                const centerShiftY = (dHeight - img.height * ratio) / 2;
                this.ctx.drawImage(img, 0, 0, img.width, img.height,
                    dx + centerShiftX, dy + centerShiftY, img.width * ratio, img.height * ratio);
            }

            _drawSinglePolaroid(img, text, decoMap, filterValue, font) {
                const { PADDING, IMG_SIZE, TEXT_AREA_HEIGHT, POLAROID_WIDTH, POLAROID_HEIGHT, FONT_SIZE } = this.CONSTANTS;
                const polaroidBg = getComputedStyle(document.documentElement).getPropertyValue('--polaroid-bg').trim();

                this.ctx.shadowColor = 'rgba(60, 60, 80, 0.15)';
                this.ctx.shadowBlur = 40;
                this.ctx.shadowOffsetY = 20;
                this.ctx.fillStyle = polaroidBg;
                this.ctx.fillRect(0, 0, POLAROID_WIDTH, POLAROID_HEIGHT);
                this.ctx.shadowColor = 'transparent';

                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.rect(PADDING, PADDING, IMG_SIZE, IMG_SIZE);
                this.ctx.clip();
                this.ctx.filter = filterValue;
                this._drawImageWithAspectRatio(img, PADDING, PADDING, IMG_SIZE, IMG_SIZE);
                this.ctx.filter = 'none';
                this.ctx.restore();

                for (const [id, decoImg] of decoMap.entries()) {
                    const d = this.config.decorations[id];
                    if (id === 'tape-top') this.ctx.drawImage(decoImg, (POLAROID_WIDTH - d.w) / 2, -20, d.w, d.h);
                    else if (id === 'ribbon-decoration') this.ctx.drawImage(decoImg, (POLAROID_WIDTH - d.w) / 2, PADDING + IMG_SIZE + TEXT_AREA_HEIGHT - d.h - 10, d.w, d.h);
                }

                if (text) {
                    this.ctx.fillStyle = '#444';
                    this.ctx.font = `600 ${FONT_SIZE}px '${font}'`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(text, POLAROID_WIDTH / 2, PADDING + IMG_SIZE + (TEXT_AREA_HEIGHT / 2));
                }
            }

            async createDownloadableCanvas(options) {
                const { layout, images, text, filter, font, decorations } = options;
                const { loadedImages, decoMap } = await this._loadAssets(images, decorations);
                if (loadedImages.length === 0) throw new Error("No images to draw.");

                const { POLAROID_WIDTH, POLAROID_HEIGHT, GRID_GAP } = this.CONSTANTS;
                
                let cols = 1, rows = 1;
                if (layout === 'grid-2x2') { cols = 2; rows = 2; }
                else if (layout === 'grid-strip' || layout === 'grid-4x1') { rows = 4; }
                
                this.canvas.width = cols * POLAROID_WIDTH + (cols - 1) * GRID_GAP;
                this.canvas.height = rows * POLAROID_HEIGHT + (rows - 1) * GRID_GAP;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                const filterValue = this.config.filters[filter].value;
                
                for (let i = 0; i < loadedImages.length; i++) {
                    const isLastImage = i === loadedImages.length - 1;
                    const currentText = isLastImage ? text : '';
                    const currentDecos = (layout === 'single' || i === 0) ? decoMap : new Map();

                    const row = Math.floor(i / cols);
                    const col = i % cols;
                    const x = col * (POLAROID_WIDTH + GRID_GAP);
                    const y = row * (POLAROID_HEIGHT + GRID_GAP);

                    this.ctx.save();
                    this.ctx.translate(x, y);
                    this._drawSinglePolaroid(loadedImages[i], currentText, currentDecos, filterValue, font);
                    this.ctx.restore();
                }
                
                return this.canvas;
            }
        }


        class PolaroidMaker {
            constructor() {
                this._initConfig();
                this._initDOM();
                this._initState();
                this._initUI();
                this._bindEvents();
                this._updateUI();
            }

            _initConfig() {
                this.config = {
                    filters: { 'none': { name: 'None', value: 'none' }, 'vintage': { name: 'Vintage', value: 'sepia(0.35) contrast(1.1) brightness(1.05) saturate(1.2)' }, 'mono': { name: 'Mono', value: 'grayscale(1)' }, 'retro': { name: 'Retro', value: 'sepia(0.6) contrast(0.9) brightness(1.1)' }, 'gloomy': { name: 'Gloomy', value: 'contrast(1.2) brightness(0.9) saturate(0.8)' }, 'mellow': { name: 'Mellow', value: 'brightness(1.1) contrast(0.95) saturate(0.9)' }, 'dreamy': { name: 'Dreamy', value: 'saturate(1.4) contrast(0.9) brightness(1.1) blur(0.5px)' }, 'lomo': { name: 'Lomo', value: 'saturate(1.5) contrast(1.2)' }, },
                    fonts: { 'Caveat': 'Cute', 'Patrick Hand': 'Neat', 'Rock Salt': 'Bold', 'Special Elite': 'Typed' },
                    decorations: { 'image-decoration': { name: 'heart', url: 'assets/heart.png', w: 150, h: 150 }, 'ribbon-decoration': { name: 'Ribbon', url: 'assets/ribbon.png', w: 120, h: 60 }, }
                };
                this.canvasDrawer = new CanvasDrawer(this.config);
            }
            
            _initDOM() {
                this.els = {
                    video: document.getElementById('videoElement'), canvas: document.getElementById('canvas'), startCameraBtn: document.getElementById('startCameraBtn'), switchCameraBtn: document.getElementById('switchCameraBtn'), captureBtn: document.getElementById('captureBtn'), uploadBtn: document.getElementById('uploadBtn'), fileInput: document.getElementById('fileInput'), downloadBtn: document.getElementById('downloadBtn'), polaroidContainer: document.getElementById('polaroidContainer'), polaroidText: document.getElementById('polaroidText'), flashEffect: document.getElementById('flashEffect'), cameraOverlay: document.getElementById('cameraOverlay'), emptyState: document.getElementById('emptyState'), layoutOptions: document.getElementById('layoutOptions'), startTimerBtn: document.getElementById('startTimerBtn'), timerDelay: document.getElementById('timerDelay'), photoCount: document.getElementById('photoCount'), timerStatus: document.getElementById('timerStatus'), countdownOverlay: document.getElementById('countdownOverlay'), countdownNumber: document.getElementById('countdownNumber'),
                    filterOptions: document.getElementById('filterOptions'), fontOptions: document.getElementById('fontOptions'), decorationOptions: document.getElementById('decorationOptions'),
                    downloadBtnText: document.querySelector('#downloadBtn .btn-text'),
                    downloadBtnSpinner: document.querySelector('#downloadBtn .spinner'),
                };
            }

            _initState() {
                this.ctx = this.els.canvas.getContext('2d');
                this.state = {
                    layout: 'single', filter: 'none', font: 'Caveat',
                    decorations: new Set(),
                    capturedImages: [],
                    isStreaming: false,
                    isTimerActive: false,
                    facingMode: 'user',
                    stream: null,
                    videoDeviceCount: 0,
                };
            }
            
            _initUI() {
                const filterPreviewUrl = 'assets/img.jpg'; // Use a sample image for filter previews
                this.els.filterOptions.innerHTML = Object.entries(this.config.filters).map(([id, { name, value }]) => `
                    <div class="grid-option filter-option" data-filter="${id}">
                        <div class="filter-preview" style="background-image: url('${filterPreviewUrl}'); filter: ${value};"></div>
                        <div class="option-name">${name}</div>
                    </div>`).join('');

                this.els.fontOptions.innerHTML = Object.entries(this.config.fonts).map(([font, name]) => `
                    <div class="grid-option font-option" data-font="${font}">
                        <div class="font-preview font-${font.replace(/\s/g, '-')}">Ag</div>
                        <div class="option-name">${name}</div>
                    </div>`).join('');

                this.els.decorationOptions.innerHTML = Object.entries(this.config.decorations).map(([id, { url, name }]) => `
                     <div class="grid-option decoration-option" data-decoration="${id}">
                        <div class="decoration-preview" style="background-image: url('${url}')"></div>
                        <div class="option-name">${name}</div>
                     </div>`).join('');
                
                this._setActiveOption(this.els.layoutOptions, `[data-layout="${this.state.layout}"]`);
                this._setActiveOption(this.els.filterOptions, `[data-filter="${this.state.filter}"]`);
                this._setActiveOption(this.els.fontOptions, `[data-font="${this.state.font}"]`);
                this.els.polaroidText.style.fontFamily = `'${this.state.font}', cursive`;
            }
            
            _updateUI() {
                const hasImages = this.state.capturedImages.length > 0;
                this.els.captureBtn.disabled = !this.state.isStreaming;
                this.els.startTimerBtn.disabled = !this.state.isStreaming;
                this.els.downloadBtn.disabled = !hasImages || this.state.isTimerActive;
                this.els.switchCameraBtn.disabled = !this.state.isStreaming || this.state.videoDeviceCount <= 1;
                this.els.emptyState.classList.toggle('hidden', hasImages);
            }
            
            _handleOptionSelection(container, selector, callback) {
                container.addEventListener('click', (e) => {
                    const option = e.target.closest(selector);
                    if (!option) return;
                    if (option.classList.contains('decoration-option')) {
                        option.classList.toggle('active');
                    } else {
                        this._setActiveOption(container, option);
                    }
                    callback(option);
                });
            }

            _setActiveOption(container, selector) {
                const option = typeof selector === 'string' ? container.querySelector(selector) : selector;
                if (!option) return;
                [...container.children].forEach(child => child.classList.remove('active'));
                option.classList.add('active');
            }

            _bindEvents() {
                this.els.startCameraBtn.addEventListener('click', () => this.startCamera());
                this.els.captureBtn.addEventListener('click', () => this.capturePhoto());
                this.els.uploadBtn.addEventListener('click', () => this.els.fileInput.click());
                this.els.fileInput.addEventListener('change', (e) => this.handleFileUpload(e));
                this.els.downloadBtn.addEventListener('click', () => this.downloadPolaroid());
                this.els.polaroidText.addEventListener('input', () => this.renderPolaroid());
                this.els.startTimerBtn.addEventListener('click', () => this.startTimer());
                this.els.switchCameraBtn.addEventListener('click', () => this.switchCamera());
                
                this._handleOptionSelection(this.els.layoutOptions, '.layout-option', el => {
                    this.state.layout = el.dataset.layout;
                    const maxPhotos = this._getMaxImagesForLayout();
                    this.els.photoCount.max = maxPhotos;
                    if (parseInt(this.els.photoCount.value) > maxPhotos) this.els.photoCount.value = maxPhotos;
                    this.renderPolaroid();
                });
                
                this._handleOptionSelection(this.els.filterOptions, '.filter-option', el => {
                    this.state.filter = el.dataset.filter;
                    this.renderPolaroid();
                });

                this._handleOptionSelection(this.els.fontOptions, '.font-option', el => {
                    this.state.font = el.dataset.font;
                    this.els.polaroidText.style.fontFamily = `'${this.state.font}', cursive`;
                    this.renderPolaroid();
                });

                this._handleOptionSelection(this.els.decorationOptions, '.decoration-option', el => {
                    const decoId = el.dataset.decoration;
                    this.state.decorations.has(decoId) ? this.state.decorations.delete(decoId) : this.state.decorations.add(decoId);
                    this.renderPolaroid();
                });
            }
            
            async startCamera() {
                if (this.state.isStreaming) return this.stopCamera();

                if (this.state.stream) this.state.stream.getTracks().forEach(track => track.stop());
                try {
                    this.state.stream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal: 1920 }, height: { ideal: 1080 }, facingMode: this.state.facingMode } });
                    this.els.video.srcObject = this.state.stream;
                    this.state.isStreaming = true;
                    this.els.cameraOverlay.classList.add('hidden');
                    this.els.startCameraBtn.innerHTML = `Stop Camera`;
                    
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    this.state.videoDeviceCount = devices.filter(d => d.kind === 'videoinput').length;
                } catch (err) {
                    console.error("Camera Error:", err);
                    this.els.cameraOverlay.classList.remove('hidden');
                    this.els.cameraOverlay.textContent = 'Camera access denied.';
                }
                this._updateUI();
            }
            
            stopCamera() {
                if (this.state.stream) this.state.stream.getTracks().forEach(track => track.stop());
                this.state.isStreaming = false;
                this.state.stream = null;
                this.els.video.srcObject = null;
                this.els.cameraOverlay.classList.remove('hidden');
                this.els.cameraOverlay.textContent = 'Click "Start Camera" to begin';
                this.els.startCameraBtn.innerHTML = `Start Camera`;
                this._updateUI();
            }

            switchCamera() {
                this.state.facingMode = this.state.facingMode === 'user' ? 'environment' : 'user';
                this.startCamera();
            }

            capturePhoto() {
                if (!this.state.isStreaming) return;
                this._triggerFlash();
                this.els.canvas.width = this.els.video.videoWidth; 
                this.els.canvas.height = this.els.video.videoHeight;
                
                if (this.state.facingMode === 'user') { 
                    this.ctx.translate(this.els.canvas.width, 0); 
                    this.ctx.scale(-1, 1); 
                }

                this.ctx.drawImage(this.els.video, 0, 0, this.els.canvas.width, this.els.canvas.height);
                this.addCapturedImage(this.els.canvas.toDataURL('image/jpeg', 0.95));
                
                this.ctx.setTransform(1, 0, 0, 1, 0, 0); 
            }

            handleFileUpload(event) {
                const files = event.target.files;
                if (!files.length) return;
                Array.from(files).forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (e) => this.addCapturedImage(e.target.result);
                    reader.readAsDataURL(file);
                });
                event.target.value = ''; // Reset for same-file uploads
            }
            
            addCapturedImage(imageData) {
                const maxImages = this._getMaxImagesForLayout();
                this.state.capturedImages.push(imageData);
                while (this.state.capturedImages.length > maxImages) {
                    this.state.capturedImages.shift();
                }
                this.renderPolaroid();
                this._updateUI();
            }

            _getMaxImagesForLayout() {
                return this.state.layout === 'single' ? 1 : 4;
            }
            
            renderPolaroid() {
                if (this.state.capturedImages.length === 0) {
                    this.els.polaroidContainer.innerHTML = '';
                    this._updateUI();
                    return;
                }
                
                const text = this.els.polaroidText.value;
                const imagesToRender = this.state.capturedImages.slice(-this._getMaxImagesForLayout());
                const filterClass = `filter-${this.state.filter}`;
                
                const decorationHTML = [...this.state.decorations].map(id => {
                    return `<div class="decoration deco-${id}"></div>`;
                }).join('');

                let html = '';
                if (this.state.layout === 'single') {
                    html = `<div class="polaroid-output-area">
                        <div id="polaroid-single" class="polaroid">
                            ${decorationHTML}
                            <div class="polaroid-image-wrapper">
                                <img src="${imagesToRender[0]}" class="polaroid-image ${filterClass}" alt="Captured photo">
                            </div>
                            <div class="polaroid-text" style="font-family: '${this.state.font}', cursive;">${text}</div>
                        </div>
                    </div>`;
                } else {
                    html = `<div class="polaroid-grid-wrapper ${this.state.layout}">`;
                    const totalSlots = this._getMaxImagesForLayout();
                    for (let i = 0; i < totalSlots; i++) {
                        const imgSrc = imagesToRender[i] || 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';
                        const isTextVisible = i === (imagesToRender.length - 1);
                        const showDecorations = i === 0;

                        html += `
                        <div class="polaroid">
                            ${showDecorations ? decorationHTML : ''}
                            <div class="polaroid-image-wrapper">
                                <img src="${imgSrc}" class="polaroid-image ${filterClass}" alt="Captured photo ${i + 1}">
                            </div>
                            <div class="polaroid-text" style="font-family: '${this.state.font}', cursive;">${isTextVisible ? text : ''}</div>
                        </div>`;
                    }
                    html += `</div>`;
                }
                this.els.polaroidContainer.innerHTML = html;
                this._updateUI();
            }

            _setDownloadButtonState(isLoading) {
                this.els.downloadBtn.disabled = isLoading;
                this.els.downloadBtnText.classList.toggle('hidden', isLoading);
                this.els.downloadBtnSpinner.classList.toggle('hidden', !isLoading);
            }

            async downloadPolaroid() {
                this._setDownloadButtonState(true);
                try {
                    const canvas = await this.canvasDrawer.createDownloadableCanvas({
                        layout: this.state.layout,
                        images: this.state.capturedImages.slice(-this._getMaxImagesForLayout()),
                        text: this.els.polaroidText.value,
                        filter: this.state.filter,
                        font: this.state.font,
                        decorations: this.state.decorations
                    });

                    const link = document.createElement('a');
                    link.download = `photobooth-${this.state.layout}-${Date.now()}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                } catch (error) {
                    console.error("Download failed:", error);
                    alert("Sorry, the image could not be created. Please check the console for errors and try again.");
                } finally {
                    this._setDownloadButtonState(false);
                }
            }
            
            startTimer() {
                if (!this.state.isStreaming || this.state.isTimerActive) return;

                this.state.isTimerActive = true;
                this.state.capturedImages = []; // Clear previous images for a new sequence
                this.renderPolaroid();
                
                const photosToTake = parseInt(this.els.photoCount.value) || 4;
                const delay = parseInt(this.els.timerDelay.value) || 3;
                let photosTaken = 0;

                const sequence = () => {
                    if (photosTaken >= photosToTake) {
                        this.stopTimer();
                        return;
                    }

                    this.showCountdown(delay, photosTaken + 1, () => {
                        this.capturePhoto();
                        photosTaken++;
                        setTimeout(sequence, 1000); // 1s pause between captures
                    });
                };
                
                this.els.startTimerBtn.disabled = true;
                this.els.timerStatus.textContent = `Sequence in progress...`;
                sequence();
            }

            stopTimer() {
                this.state.isTimerActive = false;
                this.els.startTimerBtn.disabled = false;
                this.els.timerStatus.textContent = ``;
                this._updateUI();
            }

            showCountdown(seconds, photoNum, onComplete) {
                this.els.countdownOverlay.classList.add('is-active');
                let count = seconds;
                const tick = () => {
                    this.els.countdownNumber.textContent = count > 0 ? count : `ðŸ“¸ ${photoNum}`;
                    if (count > 0) {
                        count--;
                        setTimeout(tick, 1000);
                    } else {
                        setTimeout(() => {
                            this.els.countdownOverlay.classList.remove('is-active');
                            onComplete();
                        }, 800);
                    }
                };
                tick();
            }

            _triggerFlash() { 
                this.els.flashEffect.classList.add('active'); 
                setTimeout(() => this.els.flashEffect.classList.remove('active'), 300); 
            }
        }

        new PolaroidMaker();
    });
    </script>
</body>
</html>